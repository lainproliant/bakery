# Bakery: A Python build system straight out of the oven

Bakery is a dependency driven build system atop the
[Xeno](https://github.com/lainproliant/xeno) injection framework.
Bakery allows you to define the structure and flow of your build process using
plain Python code.  Bakery mixes the ease of use of Makefiles with the power and
expressiveness of the Python language.

### Note
Bakery is still in early development.  There may be some rough edges or major
bugs.  You are encouraged to try it out now and have fun, but keep in mind that
this is a living project and there's plenty more to come!

# Installation

Installation is simple. With python3-pip, do the following:

```
$ sudo pip install -e .
```

Or, to install the latest version available on PyPI:

```
$ sudo pip install bakery-build
```

Bakery is now available via the `bake` command:

```
$ bake
```

# Usage
The first step to using Bakery is to create a `Bakefile.py` in your project.
This is a Python script that is executed via the `bake` command and contains
your *build module* definition.  This module establishes the setup methods,
inputs, outputs, temporary resources and targets that are needed to build your
project.

Via Xeno, dependencies are declared via the parameters provided to each target
method.  Each target, input, output, and temporary resource may be defined as a
coroutine or return an coroutine or list of coroutines.  When coroutines are
used this way, bakery will schedule them in the current event loop.  Using
`asyncio` and the built-in `shell` coroutine, it becomes easy to define a build
workflow that can be run in parallel.

## Example

This simple example defines a `Bakefile.py` for a simple C project containing 
number of source files which are linked into a resulting executable.

```
@build
class Bakefile:
    @recipe(check='src', temp='obj')
    async def compile(self, src, obj, log: 'log'):
        await shell('cc', '-c', src, '-o', obj, log = log)
        return obj

    @recipe('executable', check='objects')
    async def link(self, objects, executable, log: 'log'):
        await shell('cc', objects, '-o', executable, log = log)
        return executable

    @recipe()
    async def warn(self, log: 'log'):
        log.warning('OH NOES')

    @provide
    def warning(self, log: 'bakery/log'):
        log.warning('OH NOES')
        return self.warn()

    @provide
    def sources(self):
        return File.glob('src/*.c') 
   
    @provide
    def objects(self, sources):
        return [self.compile(x, File.ext(x, 'o')) for x in sources]

    @default
    def executable(self, objects):
        return self.link(objects, 'executable')
```

In the above example, the following Bakery patterns are used:

- `@build` wraps the module so that it is evaluated by Bakery as a build module.
    More than one module may be decorated with `@build`, but no more than one
    target may be marked as `@default` among them.

- `@recipe` marks a given function as defining a recipe for creating files.
    The modification time of the input files is compared to the output if it
    exists to determine if the recipe needs to be executed.  Recipes should
    generally return the name or names of the output files generated by the
    recipe.  The decorator takes the following arguments:
    - `*args`: Names of parameters to the decorated function that represent
               the outputs generated by the recipe.
    - `check`: A string or list of strings indicating parameters containing
               filenames or list of filenames that represent inputs to the
               recipe.  Bakery uses the modification time on these files
               to determine if the recipe should be run.
    - `temp`:  Refers to parameters containing files that should be cleaned up
               once the recipe finishes running.
   Additionally, the decorated function may define annotated variables into which
   special values are injected as follows:
    - `log`: This parameter is provided with a logger specific to the recipe run.

- `shell`: This is a coroutine wrapper to `asyncio.create_subprocess_exec` which 
    captures and returns the output from the command as well as printing its
    output and error output to the bakery logger.  Prefer this function for
    executing other programs such as compilers, unless the program requires a tty.

- `@provide` is an annotation from
    [Xeno](https://github.com/lainproliant/python3-xeno), marking the given
    method as a named resource that can be injected into other resources (and
    build targets) via their parameter names.  Any Xeno resource is a 
    

- `@default` marks the method as a valid nameable target and the default target
    to be executed when no other targets are specified.

### Note
To make the most out of Bakery, you should first read up on
[Xeno](https://github.com/lainproliant/python3-xeno).  *Build modules* in Bakery
are Xeno modules as well, allowing you to require and use resources defined in
other Xeno modules, such as the runtime parts of your Xeno-based project.

